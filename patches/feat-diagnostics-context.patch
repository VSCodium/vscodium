--- vscode/src/vs/workbench/contrib/chat/browser/contrib/chatImplicitContext.ts.original	2025-08-09 02:56:32.173560529 +0000
+++ vscode/src/vs/workbench/contrib/chat/browser/contrib/chatImplicitContext.ts	2025-08-09 02:57:56.031916998 +0000
@@ -1,396 +1,337 @@
-/*------------------------------------------------------------------------------
----------------
+/*---------------------------------------------------------------------------------------------
  *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for lice
-nse information.
- *------------------------------------------------------------------------------
---------------*/
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/

-import { CancellationTokenSource } from '../../../../../base/common/cancellation
-.js';
+import { CancellationTokenSource } from '../../../../../base/common/cancellation.js';
 import { Emitter, Event } from '../../../../../base/common/event.js';
-import { Disposable, DisposableStore, MutableDisposable } from '../../../../../b
-ase/common/lifecycle.js';
+import { Disposable, DisposableStore, MutableDisposable } from '../../../../../base/common/lifecycle.js';
 import { Schemas } from '../../../../../base/common/network.js';
 import { autorun } from '../../../../../base/common/observable.js';
 import { basename, isEqual } from '../../../../../base/common/resources.js';
 import { URI } from '../../../../../base/common/uri.js';
-import { getCodeEditor, ICodeEditor } from '../../../../../editor/browser/editor
-Browser.js';
-import { ICodeEditorService } from '../../../../../editor/browser/services/codeE
-ditorService.js';
+import { getCodeEditor, ICodeEditor } from '../../../../../editor/browser/editorBrowser.js';
+import { ICodeEditorService } from '../../../../../editor/browser/services/codeEditorService.js';
 import { Location } from '../../../../../editor/common/languages.js';
-import { IConfigurationService } from '../../../../../platform/configuration/com
-mon/configuration.js';
+import { IConfigurationService } from '../../../../../platform/configuration/common/configuration.js';
+import { IMarker, MarkerSeverity, IMarkerService } from '../../../../../platform/markers/common/markers.js';
 import { IWorkbenchContribution } from '../../../../common/contributions.js';
 import { EditorsOrder } from '../../../../common/editor.js';
-import { IEditorService } from '../../../../services/editor/common/editorService
-.js';
-import { getNotebookEditorFromEditorPane, INotebookEditor } from '../../../noteb
-ook/browser/notebookBrowser.js';
+import { IEditorService } from '../../../../services/editor/common/editorService.js';
+import { getNotebookEditorFromEditorPane, INotebookEditor } from '../../../notebook/browser/notebookBrowser.js';
 import { IChatEditingService } from '../../common/chatEditingService.js';
-import { IChatRequestImplicitVariableEntry, IChatRequestVariableEntry } from '..
-/../common/chatVariableEntries.js';
+import { IChatRequestImplicitVariableEntry, IChatRequestVariableEntry, IDiagnosticVariableEntryFilterData } from '../../common/chatVariableEntries.js';
 import { IChatService } from '../../common/chatService.js';
 import { ChatAgentLocation } from '../../common/constants.js';
-import { ILanguageModelIgnoredFilesService } from '../../common/ignoredFiles.js'
-;
-import { getPromptsTypeForLanguageId } from '../../common/promptSyntax/promptTyp
-es.js';
+import { IMarker } from '../../../../../platform/markers/common/markers.js';
+import { ILanguageModelIgnoredFilesService } from '../../common/ignoredFiles.js';
+import { getPromptsTypeForLanguageId } from '../../common/promptSyntax/promptTypes.js';
 import { IChatWidget, IChatWidgetService } from '../chat.js';

-export class ChatImplicitContextContribution extends Disposable implements IWork
-benchContribution {
-        static readonly ID = 'chat.implicitContext';
-
-        private readonly _currentCancelTokenSource: MutableDisposable<Cancellati
-onTokenSource>;
-
-        private _implicitContextEnablement: { [mode: string]: string };
-
-        constructor(
-                @ICodeEditorService private readonly codeEditorService: ICodeEdi
-torService,
-                @IEditorService private readonly editorService: IEditorService,
-                @IChatWidgetService private readonly chatWidgetService: IChatWid
-getService,
-                @IChatService private readonly chatService: IChatService,
-                @IChatEditingService private readonly chatEditingService: IChatE
-ditingService,
-                @IConfigurationService private readonly configurationService: IC
-onfigurationService,
-                @ILanguageModelIgnoredFilesService private readonly ignoredFiles
-Service: ILanguageModelIgnoredFilesService,
-        ) {
-                super();
-                this._currentCancelTokenSource = this._register(new MutableDispo
-sable<CancellationTokenSource>());
-                this._implicitContextEnablement = this.configurationService.getV
-alue<{ [mode: string]: string }>('chat.implicitContext.enabled');
-
-                const activeEditorDisposables = this._register(new DisposableSto
-re());
-
-                this._register(Event.runAndSubscribe(
-                        editorService.onDidActiveEditorChange,
-                        (() => {
-                                activeEditorDisposables.clear();
-                                const codeEditor = this.findActiveCodeEditor();
-                                if (codeEditor) {
-                                        activeEditorDisposables.add(Event.deboun
-ce(
-                                                Event.any(
-                                                        codeEditor.onDidChangeMo
-del,
-                                                        codeEditor.onDidChangeMo
-delLanguage,
-                                                        codeEditor.onDidChangeCu
-rsorSelection,
-                                                        codeEditor.onDidScrollCh
-ange),
-                                                () => undefined,
-                                                500)(() => this.updateImplicitCo
-ntext()));
-                                }
-
-                                const notebookEditor = this.findActiveNotebookEd
-itor();
-                                if (notebookEditor) {
-                                        const activeCellDisposables = activeEdit
-orDisposables.add(new DisposableStore());
-                                        activeEditorDisposables.add(notebookEdit
-or.onDidChangeActiveCell(() => {
-                                                activeCellDisposables.clear();
-                                                const codeEditor = this.codeEdit
-orService.getActiveCodeEditor();
-                                                if (codeEditor && codeEditor.get
-Model()?.uri.scheme === Schemas.vscodeNotebookCell) {
-                                                        activeCellDisposables.ad
-d(Event.debounce(
-                                                                Event.any(
-                                                                        codeEdit
-or.onDidChangeModel,
-                                                                        codeEdit
-or.onDidChangeCursorSelection,
-                                                                        codeEdit
-or.onDidScrollChange),
-                                                                () => undefined,
-                                                                500)(() => this.
-updateImplicitContext()));
-                                                }
-                                        }));
-
-                                        activeEditorDisposables.add(Event.deboun
-ce(
-                                                Event.any(
-                                                        notebookEditor.onDidChan
-geModel,
-                                                        notebookEditor.onDidChan
-geActiveCell
-                                                ),
-                                                () => undefined,
-                                                500)(() => this.updateImplicitCo
-ntext()));
-                                }
-
-                                this.updateImplicitContext();
-                        })));
-                this._register(autorun((reader) => {
-                        this.chatEditingService.editingSessionsObs.read(reader);
-                        this.updateImplicitContext();
-                }));
-                this._register(this.configurationService.onDidChangeConfiguratio
-n(e => {
-                        if (e.affectsConfiguration('chat.implicitContext.enabled
-')) {
-                                this._implicitContextEnablement = this.configura
-tionService.getValue<{ [mode: string]: string }>('chat.implicitContext.enabled')
-;
-                                this.updateImplicitContext();
-                        }
-                }));
-                this._register(this.chatService.onDidSubmitRequest(({ chatSessio
-nId }) => {
-                        const widget = this.chatWidgetService.getWidgetBySession
-Id(chatSessionId);
-                        if (!widget?.input.implicitContext) {
-                                return;
-                        }
-                        if (this._implicitContextEnablement[widget.location] ===
- 'first' && widget.viewModel?.getItems().length !== 0) {
-                                widget.input.implicitContext.setValue(undefined,
- false, undefined);
-                        }
-                }));
-                this._register(this.chatWidgetService.onDidAddWidget(async (widg
-et) => {
-                        await this.updateImplicitContext(widget);
-                }));
-        }
-
-        private findActiveCodeEditor(): ICodeEditor | undefined {
-                const codeEditor = this.codeEditorService.getActiveCodeEditor();
-                if (codeEditor) {
-                        const model = codeEditor.getModel();
-                        if (model?.uri.scheme === Schemas.vscodeNotebookCell) {
-                                return undefined;
-                        }
-
-                        if (model) {
-                                return codeEditor;
-                        }
-                }
-                for (const codeOrDiffEditor of this.editorService.getVisibleText
-EditorControls(EditorsOrder.MOST_RECENTLY_ACTIVE)) {
-                        const codeEditor = getCodeEditor(codeOrDiffEditor);
-                        if (!codeEditor) {
-                                continue;
-                        }
-
-                        const model = codeEditor.getModel();
-                        if (model) {
-                                return codeEditor;
-                        }
-                }
-                return undefined;
-        }
-
-        private findActiveNotebookEditor(): INotebookEditor | undefined {
-                return getNotebookEditorFromEditorPane(this.editorService.active
-EditorPane);
-        }
-
-        private async updateImplicitContext(updateWidget?: IChatWidget): Promise
-<void> {
-                const cancelTokenSource = this._currentCancelTokenSource.value =
- new CancellationTokenSource();
-                const codeEditor = this.findActiveCodeEditor();
-                const model = codeEditor?.getModel();
-                const selection = codeEditor?.getSelection();
-                let newValue: Location | URI | undefined;
-                let isSelection = false;
-
-                let languageId: string | undefined;
-                if (model) {
-                        languageId = model.getLanguageId();
-                        if (selection && !selection.isEmpty()) {
-                                newValue = { uri: model.uri, range: selection }
-satisfies Location;
-                                isSelection = true;
-                        } else {
-                                const visibleRanges = codeEditor?.getVisibleRang
-es();
-                                if (visibleRanges && visibleRanges.length > 0) {
-                                        // Merge visible ranges. Maybe the refer
-ence value could actually be an array of Locations?
-                                        // Something like a Location with an arr
-ay of Ranges?
-                                        let range = visibleRanges[0];
-                                        visibleRanges.slice(1).forEach(r => {
-                                                range = range.plusRange(r);
-                                        });
-                                        newValue = { uri: model.uri, range } sat
-isfies Location;
-                                } else {
-                                        newValue = model.uri;
-                                }
-                        }
-                }
-
-                const notebookEditor = this.findActiveNotebookEditor();
-                if (notebookEditor) {
-                        const activeCell = notebookEditor.getActiveCell();
-                        if (activeCell) {
-                                const codeEditor = this.codeEditorService.getAct
-iveCodeEditor();
-                                const selection = codeEditor?.getSelection();
-                                const visibleRanges = codeEditor?.getVisibleRang
-es() || [];
-                                newValue = activeCell.uri;
-                                if (isEqual(codeEditor?.getModel()?.uri, activeC
-ell.uri)) {
-                                        if (selection && !selection.isEmpty()) {
-                                                newValue = { uri: activeCell.uri
-, range: selection } satisfies Location;
-                                                isSelection = true;
-                                        } else if (visibleRanges.length > 0) {
-                                                // Merge visible ranges. Maybe t
-he reference value could actually be an array of Locations?
-                                                // Something like a Location wit
-h an array of Ranges?
-                                                let range = visibleRanges[0];
-                                                visibleRanges.slice(1).forEach(r
- => {
-                                                        range = range.plusRange(
-r);
-                                                });
-                                                newValue = { uri: activeCell.uri
-, range } satisfies Location;
-                                        }
-                                }
-                        } else {
-                                newValue = notebookEditor.textModel?.uri;
-                        }
-                }
-
-                const uri = newValue instanceof URI ? newValue : newValue?.uri;
-                if (uri && (
-                        await this.ignoredFilesService.fileIsIgnored(uri, cancel
-TokenSource.token) ||
-                        uri.path.endsWith('.copilotmd'))
-                ) {
-                        newValue = undefined;
-                }
-
-                if (cancelTokenSource.token.isCancellationRequested) {
-                        return;
-                }
-
-                const isPromptFile = languageId && getPromptsTypeForLanguageId(l
-anguageId) !== undefined;
-
-                const widgets = updateWidget ? [updateWidget] : [...this.chatWid
-getService.getWidgetsByLocations(ChatAgentLocation.Panel), ...this.chatWidgetSer
-vice.getWidgetsByLocations(ChatAgentLocation.Editor)];
-                for (const widget of widgets) {
-                        if (!widget.input.implicitContext) {
-                                continue;
-                        }
-                        const setting = this._implicitContextEnablement[widget.l
-ocation];
-                        const isFirstInteraction = widget.viewModel?.getItems().
-length === 0;
-                        if ((setting === 'always' || setting === 'first' && isFi
-rstInteraction) && !isPromptFile) { // disable implicit context for prompt files
-                                widget.input.implicitContext.setValue(newValue,
-isSelection, languageId);
-                        } else {
-                                widget.input.implicitContext.setValue(undefined,
- false, undefined);
-                        }
-                }
-        }
+export class ChatImplicitContextContribution extends Disposable implements IWorkbenchContribution {
+	static readonly ID = 'chat.implicitContext';
+
+	private readonly _currentCancelTokenSource: MutableDisposable<CancellationTokenSource>;
+
+	private _implicitContextEnablement: { [mode: string]: string };
+
+	constructor(
+		@ICodeEditorService private readonly codeEditorService: ICodeEditorService,
+		@IEditorService private readonly editorService: IEditorService,
+		@IChatWidgetService private readonly chatWidgetService: IChatWidgetService,
+		@IChatService private readonly chatService: IChatService,
+		@IChatEditingService private readonly chatEditingService: IChatEditingService,
+		@IConfigurationService private readonly configurationService: IConfigurationService,
+		@ILanguageModelIgnoredFilesService private readonly ignoredFilesService: ILanguageModelIgnoredFilesService,
+		@IMarkerService private readonly markerService: IMarkerService,
+	) {
+		super();
+		this._currentCancelTokenSource = this._register(new MutableDisposable<CancellationTokenSource>());
+		this._implicitContextEnablement = this.configurationService.getValue<{ [mode: string]: string }>('chat.implicitContext.enabled');
+
+		const activeEditorDisposables = this._register(new DisposableStore());
+
+		this._register(Event.runAndSubscribe(
+			editorService.onDidActiveEditorChange,
+			(() => {
+				activeEditorDisposables.clear();
+				const codeEditor = this.findActiveCodeEditor();
+				if (codeEditor) {
+					activeEditorDisposables.add(Event.debounce(
+						Event.any(
+							codeEditor.onDidChangeModel,
+							codeEditor.onDidChangeModelLanguage,
+							codeEditor.onDidChangeCursorSelection,
+							codeEditor.onDidScrollChange),
+						() => undefined,
+						500)(() => this.updateImplicitContext()));
+				}
+
+				const notebookEditor = this.findActiveNotebookEditor();
+				if (notebookEditor) {
+					const activeCellDisposables = activeEditorDisposables.add(new DisposableStore());
+					activeEditorDisposables.add(notebookEditor.onDidChangeActiveCell(() => {
+						activeCellDisposables.clear();
+						const codeEditor = this.codeEditorService.getActiveCodeEditor();
+						if (codeEditor && codeEditor.getModel()?.uri.scheme === Schemas.vscodeNotebookCell) {
+							activeCellDisposables.add(Event.debounce(
+								Event.any(
+									codeEditor.onDidChangeModel,
+									codeEditor.onDidChangeCursorSelection,
+									codeEditor.onDidScrollChange),
+								() => undefined,
+								500)(() => this.updateImplicitContext()));
+						}
+					}));
+
+					activeEditorDisposables.add(Event.debounce(
+						Event.any(
+							notebookEditor.onDidChangeModel,
+							notebookEditor.onDidChangeActiveCell
+						),
+						() => undefined,
+						500)(() => this.updateImplicitContext()));
+				}
+
+				this.updateImplicitContext();
+			})));
+		this._register(autorun((reader) => {
+			this.chatEditingService.editingSessionsObs.read(reader);
+			this.updateImplicitContext();
+		}));
+		this._register(this.configurationService.onDidChangeConfiguration(e => {
+			if (e.affectsConfiguration('chat.implicitContext.enabled')) {
+				this._implicitContextEnablement = this.configurationService.getValue<{ [mode: string]: string }>('chat.implicitContext.enabled');
+				this.updateImplicitContext();
+			}
+		}));
+		this._register(this.chatService.onDidSubmitRequest(({ chatSessionId }) => {
+			const widget = this.chatWidgetService.getWidgetBySessionId(chatSessionId);
+			if (!widget?.input.implicitContext) {
+				return;
+			}
+			if (this._implicitContextEnablement[widget.location] === 'first' && widget.viewModel?.getItems().length !== 0) {
+				widget.input.implicitContext.setValue(undefined, false, undefined);
+			}
+		}));
+		this._register(this.chatWidgetService.onDidAddWidget(async (widget) => {
+			await this.updateImplicitContext(widget);
+		}));
+	}
+
+	private findActiveCodeEditor(): ICodeEditor | undefined {
+		const codeEditor = this.codeEditorService.getActiveCodeEditor();
+		if (codeEditor) {
+			const model = codeEditor.getModel();
+			if (model?.uri.scheme === Schemas.vscodeNotebookCell) {
+				return undefined;
+			}
+
+			if (model) {
+				return codeEditor;
+			}
+		}
+		for (const codeOrDiffEditor of this.editorService.getVisibleTextEditorControls(EditorsOrder.MOST_RECENTLY_ACTIVE)) {
+			const codeEditor = getCodeEditor(codeOrDiffEditor);
+			if (!codeEditor) {
+				continue;
+			}
+
+			const model = codeEditor.getModel();
+			if (model) {
+				return codeEditor;
+			}
+		}
+		return undefined;
+	}
+
+	private findActiveNotebookEditor(): INotebookEditor | undefined {
+		return getNotebookEditorFromEditorPane(this.editorService.activeEditorPane);
+	}
+
+	private async updateImplicitContext(updateWidget?: IChatWidget): Promise<void> {
+		const cancelTokenSource = this._currentCancelTokenSource.value = new CancellationTokenSource();
+		const codeEditor = this.findActiveCodeEditor();
+		const model = codeEditor?.getModel();
+		const selection = codeEditor?.getSelection();
+		let newValue: Location | URI | undefined;
+		let isSelection = false;
+
+		let languageId: string | undefined;
+		if (model) {
+			languageId = model.getLanguageId();
+			if (selection && !selection.isEmpty()) {
+				newValue = { uri: model.uri, range: selection } satisfies Location;
+				isSelection = true;
+			} else {
+				const visibleRanges = codeEditor?.getVisibleRanges();
+				if (visibleRanges && visibleRanges.length > 0) {
+					// Merge visible ranges. Maybe the reference value could actually be an array of Locations?
+					// Something like a Location with an array of Ranges?
+					let range = visibleRanges[0];
+					visibleRanges.slice(1).forEach(r => {
+						range = range.plusRange(r);
+					});
+					newValue = { uri: model.uri, range } satisfies Location;
+				} else {
+					newValue = model.uri;
+				}
+			}
+		}
+
+		const notebookEditor = this.findActiveNotebookEditor();
+		if (notebookEditor) {
+			const activeCell = notebookEditor.getActiveCell();
+			if (activeCell) {
+				const codeEditor = this.codeEditorService.getActiveCodeEditor();
+				const selection = codeEditor?.getSelection();
+				const visibleRanges = codeEditor?.getVisibleRanges() || [];
+				newValue = activeCell.uri;
+				if (isEqual(codeEditor?.getModel()?.uri, activeCell.uri)) {
+					if (selection && !selection.isEmpty()) {
+						newValue = { uri: activeCell.uri, range: selection } satisfies Location;
+						isSelection = true;
+					} else if (visibleRanges.length > 0) {
+						// Merge visible ranges. Maybe the reference value could actually be an array of Locations?
+						// Something like a Location with an array of Ranges?
+						let range = visibleRanges[0];
+						visibleRanges.slice(1).forEach(r => {
+							range = range.plusRange(r);
+						});
+						newValue = { uri: activeCell.uri, range } satisfies Location;
+					}
+				}
+			} else {
+				newValue = notebookEditor.textModel?.uri;
+			}
+		}
+
+		const uri = newValue instanceof URI ? newValue : newValue?.uri;
+		if (uri && (
+			await this.ignoredFilesService.fileIsIgnored(uri, cancelTokenSource.token) ||
+			uri.path.endsWith('.copilotmd'))
+		) {
+			newValue = undefined;
+		}
+
+		if (cancelTokenSource.token.isCancellationRequested) {
+			return;
+		}
+
+		const isPromptFile = languageId && getPromptsTypeForLanguageId(languageId) !== undefined;
+
+		const widgets = updateWidget ? [updateWidget] : [...this.chatWidgetService.getWidgetsByLocations(ChatAgentLocation.Panel), ...this.chatWidgetService.getWidgetsByLocations(ChatAgentLocation.Editor)];
+		for (const widget of widgets) {
+			if (!widget.input.implicitContext) {
+				continue;
+			}
+			const setting = this._implicitContextEnablement[widget.location];
+			const isFirstInteraction = widget.viewModel?.getItems().length === 0;
+			if ((setting === 'always' || setting === 'first' && isFirstInteraction) && !isPromptFile) { // disable implicit context for prompt files
+				widget.input.implicitContext.setValue(newValue, isSelection, languageId);
+				if (model) {
+					const markers = this.markerService.read({ resource: model.uri, severities: MarkerSeverity.Error | MarkerSeverity.Warning });
+					widget.input.implicitContext.setDiagnostics(markers);
+				}
+			} else {
+				widget.input.implicitContext.setValue(undefined, false, undefined);
+				widget.input.implicitContext.setDiagnostics([]);
+			}
+		}
+	}
 }

-export class ChatImplicitContext extends Disposable implements IChatRequestImpli
-citVariableEntry {
+export class ChatImplicitContext extends Disposable implements IChatRequestImplicitVariableEntry {

-        get id() {
-                if (URI.isUri(this.value)) {
-                        return 'vscode.implicit.file';
-                } else if (this.value) {
-                        if (this._isSelection) {
-                                return 'vscode.implicit.selection';
-                        } else {
-                                return 'vscode.implicit.viewport';
-                        }
-                } else {
-                        return 'vscode.implicit';
-                }
-        }
-
-        get name(): string {
-                if (URI.isUri(this.value)) {
-                        return `file:${basename(this.value)}`;
-                } else if (this.value) {
-                        return `file:${basename(this.value.uri)}`;
-                } else {
-                        return 'implicit';
-                }
-        }
-
-        readonly kind = 'implicit';
-
-        get modelDescription(): string {
-                if (URI.isUri(this.value)) {
-                        return `User's active file`;
-                } else if (this._isSelection) {
-                        return `User's active selection`;
-                } else {
-                        return `User's current visible code`;
-                }
-        }
-
-        readonly isFile = true;
-
-        private _isSelection = false;
-        public get isSelection(): boolean {
-                return this._isSelection;
-        }
-
-        private _onDidChangeValue = this._register(new Emitter<void>());
-        readonly onDidChangeValue = this._onDidChangeValue.event;
-
-        private _value: Location | URI | undefined;
-        get value() {
-                return this._value;
-        }
-
-        private _enabled = true;
-        get enabled() {
-                return this._enabled;
-        }
-
-        set enabled(value: boolean) {
-                this._enabled = value;
-                this._onDidChangeValue.fire();
-        }
-
-        setValue(value: Location | URI | undefined, isSelection: boolean, langua
-geId?: string): void {
-                this._value = value;
-                this._isSelection = isSelection;
-                this._onDidChangeValue.fire();
-        }
-
-        public toBaseEntries(): IChatRequestVariableEntry[] {
-                return [{
-                        kind: 'file',
-                        id: this.id,
-                        name: this.name,
-                        value: this.value,
-                        modelDescription: this.modelDescription,
-                }];
-        }
+	get id() {
+		if (URI.isUri(this.value)) {
+			return 'vscode.implicit.file';
+		} else if (this.value) {
+			if (this._isSelection) {
+				return 'vscode.implicit.selection';
+			} else {
+				return 'vscode.implicit.viewport';
+			}
+		} else {
+			return 'vscode.implicit';
+		}
+	}
+
+	get name(): string {
+		if (URI.isUri(this.value)) {
+			return `file:${basename(this.value)}`;
+		} else if (this.value) {
+			return `file:${basename(this.value.uri)}`;
+		} else {
+			return 'implicit';
+		}
+	}
+
+	readonly kind = 'implicit';
+
+	get modelDescription(): string {
+		if (URI.isUri(this.value)) {
+			return `User's active file`;
+		} else if (this._isSelection) {
+			return `User's active selection`;
+		} else {
+			return `User's current visible code`;
+		}
+	}
+
+	readonly isFile = true;
+
+	private _isSelection = false;
+	public get isSelection(): boolean {
+		return this._isSelection;
+	}
+
+	private _diagnostics: IMarker[] = [];
+	public setDiagnostics(diagnostics: IMarker[]): void {
+		this._diagnostics = diagnostics;
+		this._onDidChangeValue.fire();
+	}
+
+	private _onDidChangeValue = this._register(new Emitter<void>());
+	readonly onDidChangeValue = this._onDidChangeValue.event;
+
+	private _value: Location | URI | undefined;
+	get value() {
+		return this._value;
+	}
+
+	private _enabled = true;
+	get enabled() {
+		return this._enabled;
+	}
+
+	set enabled(value: boolean) {
+		this._enabled = value;
+		this._onDidChangeValue.fire();
+	}
+
+	setValue(value: Location | URI | undefined, isSelection: boolean, languageId?: string): void {
+		this._value = value;
+		this._isSelection = isSelection;
+		this._onDidChangeValue.fire();
+	}
+
+	public toBaseEntries(): IChatRequestVariableEntry[] {
+		const entries: IChatRequestVariableEntry[] = [];
+		if (this.value) {
+			entries.push({
+				kind: 'file',
+				id: this.id,
+				name: this.name,
+				value: this.value,
+				modelDescription: this.modelDescription,
+			});
+		}
+
+		for (const diagnostic of this._diagnostics) {
+			entries.push(IDiagnosticVariableEntryFilterData.toEntry(IDiagnosticVariableEntryFilterData.fromMarker(diagnostic)));
+		}

+		return entries;
+	}
 }
